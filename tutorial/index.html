<!-- DO NOT EDIT THIS FILE, IT IS GENERATED FROM index.html.script -->
<html>
<head>
    <title>Reactive Maps with Play, Akka and Java  - Activator Template</title>
</head>
<body>
<div>

    <h2>The world is going reactive</h2>

    <p>
        Not long ago, response times in the seconds were considered appropriate.  Browser refreshes were the norm in web
        applications.  Systems would go down for hours of maintenance, or even be rebooted nightly, and this was ok
        because people only expected the systems to be up during business hours.  Applications didn't have to scale
        because they didn't have big user bases.  And the complexity requirements put on web applications meant that
        typical requests could easily be handled by a thread per request model.
    </p>

    <p>
        Things are changing though.  People expect web applications to react instantly.  They expect them to be up all
        the time, while the applications are moving into the cloud, where failures are not exceptional, but rather are
        the norm, and so applications need to react to failure.  Load on a web application can peak unpredictably, to
        be many orders of magnitude greater than normal, and so applications need to react to load and scale out.  The
        complexity of business requirements means that in order to respond quickly to requests, things must
        be processed in parallel, reacting to events rather than waiting so as to utilise resources as efficiently as
        possible.
    </p>

    <p>
        This application is an example of how to implement the tenets of the
        <a href="http://www.reactivemanifesto.org/" target="_blank">Reactive Manifesto</a>.
    </p>

    <p>
        It uses Play, combined with the latest in client side technologies to implement a reactive user interface.  It
        uses Akka to provide horizontally scalable and resilient message passing and data management.
    </p>

</div>
<div>

    <h2>Browse the app</h2>

    <p>
        Before jumping into the code, let's see the app in action.  Go to the <a href="#run" class="shortcut">Run</a>
        tab, and start the application if it's not already started.  Then visit it at:
        <a href="http://localhost:9000" target="_blank">http://localhost:9000</a>.
    </p>

    <p>
        You will be presented with a screen asking for your email address.  After entering it and submitting, you should
        see a map, and you should be able to find yourself on that map (this may take a short amount of time due to the way
        data flows through summary regions in the system, the further you zoom out the less realtime the app gets).
    </p>

    <p>
        If you zoom in on North Carolina, you should see some bots walking around.  These bots are simulating other
        users, the data used to generate their paths is taken from hiking trail data that was grabbed from
        <a href="http://www.hikewnc.info/" target="_blank">HikeWNC</a>.
    </p>

</div>
<div>

    <h2>System Overview</h2>

    <p>
        The system can be broadly divided into three parts.  The first part is the client side app.  This is written
        in <a href="http://coffeescript.org/" target="_blank">CoffeeScript</a>, and runs in the browser.  The second
        part is the web front end, this is a Play application that serves web requests coming in.  The third part is
        the Akka backend, which manages the distribution of data across backend nodes, and the publishing and
        subscribing of events.
    </p>

    <p>
        In the demo you're seeing now, the Play web front end and the Akka backend are running as one application, but
        in a production scenario, they would be run separately, allowing fine grained control of resources between the
        front and backend.
    </p>

</div>
<div>

    <h2>System Overview - Client</h2>

    <p>
        The client talks to the web front end using
        <a href="http://en.wikipedia.org/wiki/WebSocket" target="_blank">WebSockets</a>:
    </p>

    <img src="tutorial/client-server.svg"/>

    <p>
        All the communication above is fire and forget, after sending a user moved event, the client doesn't need
        anything in response, after sending a viewing area message, the client might get many messages,
        or maybe none at all, depending on whether there are any users in that area, and after the server sends position
        updates, it expects nothing in return from the client.
    </p>

    <p>
        This differs from many traditional client server where clients make a request and expect a response. In a
        reactive application, much of the communication will not be request/response based, because the way reactive
        applications are architected is that data flows to consumers as it becomes available, and consumers of the data
        react to it, they don't ask for it.
    </p>

    <p>
        For this reason, WebSockets makes for a perfect transport for client server communication in a reactive
        application, since it allows events to be passed with low overhead, not needing to wait for a response, and
        facilitates reacting to events from the server.
    </p>

</div>
<div>

    <h2>System Overview - Backend</h2>

    <p>
        Before explaining the backend interface, we need to have a short lesson in geo based systems.  A naive way to
        create the reactive maps application would be to send all data from all users to every connected user.  This
        might work if there are only 10 users connected, or maybe even 100.  At 1000, each user is going to be
        downloading megabytes of updates per second - it is not going to scale.
    </p>

    <p>
        To manage this, we break the earth up into regions.  There are many different ways to do this, but in our app
        we're using the simplest to understand, we flatten the map out into a rectangle, and then divide it into many
        smaller rectangles.  How many rectangles is configurable, but we have defaulted this to 16 million.
        Because the earth is not a reactangle, but is actually a sphere, these rectangles don't all cover the same
        area, at the equator each one is a few kms wide, at the poles, each rectangle is only a few metres wide.  But
        each rectangle is a constant number of degrees in longitude wide, and degrees in latitude high, so transforming
        latitude and longitude coordinates to regions is therefore a straightforward equation.
    </p>

    <p>
        The web front end talks to the backend using Akka clustering:
    </p>

    <img src="tutorial/frontend-region.svg"/>

    <p>
        Actors in an Akka cluster may talk to each other without knowing whether they are on the same node or different
        nodes.  In the above diagram, when a frontend node receives a position update from the client, the region
        responsible for that position may be on the same node, or may be on a different node.  The web frontend doesn't
        need to worry, all it needs to know is which region to send to, and Akka will work out how to get the message
        to the right node.
    </p>
    
    <p>
        Akka distributed PubSub messaging is used to publish location updates to the frontend.  When the web frontend
        gets a new viewing area from the client, it works out which regions cover that viewing area, and then subscribes
        to updates from each of those regions.  Whether those regions are on the same node or on different nodes is
        transparent, Akka ensures that the right messages get to the right subscribers on the right nodes.  When a
        region has a new update to publish, it pushes it to the PubSub manager, which then pushes the messages to the
        right subscribers on the right nodes.
    </p>
    
    <p>
        Finally, regions get summarised into summary regions, and these summary regions are used so that clients that
        are viewing large areas at once aren't consuming too much data.  Lowest level regions and higher level summary
        regions send updates to their higher level summary region, which aggregates and publishes the information.
        When the client requests a viewing area that contains too many regions, it subscribes instead to updates from
        summary regions.
    </p>

</div>
<div>

    <h2>The code - Client side</h2>

    <p>
        Now that we've got a broad overview of the system architecture, let's start looking at the code.  We'll start
        off with tracing the code through from what happens when a users GPS enabled device sends an update.
    </p>

    <p>
        The entry point to this event flow is in
        <a href="#code/app/assets/javascripts/services/gps.coffee" class="shortcut">gps.coffee</a>.  This file contains
        a class for for handling the GPS integration of the app.  It uses the
        <a href="http://www.w3.org/TR/geolocation-API/" target="_blank">HTML5 Geolocation API</a> to watch for location
        updates from the browser.
    </p>

    <p>
        The first thing you'll find in this, and most other CoffeeScript files in this app, is a call to
        <code>define</code>.  This is a <a href="http://requirejs.org/" target="_blank">RequireJS</a> call, used to
        define a module.  RequireJS allows JavaScript to be developed in a modular way, which is important for rich
        client side apps that heavily use JavaScript like this one.  At the bottom of the file you can see a return
        statement returning the <code>Gps</code> class that we've declared, this means anything that imports our module
        will get that class back.
    </p>

    <p>
        The bulk of the code in this file is actually dealing with ensuring that neither too few, nor too many location
        updates are sent to the server.  It ensures that a location update is sent at least every 10 seconds, but no
        more frequently than every 2 seconds.  The most pertinent code that we're interested in now though is the
        <code>navigator.geolocation.watchPosition(...)</code> call, this is the HTML5 Geolocation API call to watch for
        GPS updates, and also the <code>@ws.send(...)</code> call, this sends a <code>user-moved</code> event as JSON
        through the WebSocket, with the users current position.
    </p>

    <p>
        The <code>position</code> field of this event is formatted using the <a href="http://geojson.org/">GeoJSON</a> standard,
        which you'll soon see is used throughout the application.
    </p>

    <p>
        So we can now see how location updates are obtained from the browser.  But where does the WebSocket come from
        that it's getting sent down?  You'll see that the constructor of the <code>Gps</code> class accepts the WebSocket as a
        parameter.  This constructor is called from the
        <a href="#code/app/assets/javascripts/models/mainPage.coffee" class="shortcut">mainPage.coffee</a> module.  In
        this module, you can see that in the <code>define</code> call it declares a few dependencies, one being the
        <code>./gps</code> module that we just looked at.
    </p>

    <p>
        Scroll down to the <code>connect</code> method, and you'll see the following code:
    </p>

    <pre><code>@ws = new WebSocket($("meta[name='websocketurl']").attr("content") + email)</code></pre>

    <p>
        This is the code that creates the WebSocket, and a few lines below that, in the <code>onopen</code> callback,
        you can see where we are passing the WebSocket to the <code>Gps</code> constructor.  The URL for the WebSocket
        is coming from a meta element in the page named <code>websocketurl</code>.
    </p>

    <p>
        Open <a href="#code/app/views/main.scala.html" class="shortcut">main.scala.html</a>.  This is the template
        where that meta element is defined.  The content is a call to Plays reverse router.  Play has a configuration
        file called <a href="#code/conf/routes" class="shortcut">routes</a>, this file contains all the configuration
        for how incoming requests are routed to their corresponding actions in Play.  In addition to providing this
        forward routing, Play also generates a reverse router, that code such as this template can call, and it will
        return the URL that can be used to reach that route.  This means that your path information is kept in one
        place - in your routes file, and everything else in your application can depend on it.
    </p>

    <p>
        In the routes file, you can see that the <code>/stream/:email</code> path is routed to
        <code>controllers.Application.stream</code>, so the reverse router call
        <code>@routes.Application.stream("").webSocketURL()</code> will return us that path.
    </p>

    <p>
        You can read more about routing in Play Framework
        <a href="http://www.playframework.com/documentation/latest/JavaRouting" target="_blank">here</a>.

    </p>

    <p>
        So now we've seen how the client side portion of the app locates and connects to the WebSocket, and how it
        uses that WebSocket to push location updates to the server.
    </p>

</div>
<div>

    <h2>The code - Web Frontend</h2>

    <p>
        In the <a href="#code/conf/routes" class="shortcut">routes</a> file, we saw how the WebSocket route was
        defined, and how it gets routed to the <code>controllers.Application.stream</code> method.  Let's open that
        class now, <a href="#code/app/controllers/Application.java" class="shortcut">Application.java</a>.
    </p>

    <p>
        Looking at the <code>stream</code> method, the first thing to notice is that it is declared to be a WebSocket
        action that works with <code>JsonNode</code> messages.  The format of these messages are defined in
        <a href="#code/app/actors/ClientConnectionProtocol.java" class="shortcut">ClientConnectionProtocol.java</a>, we
        can see our three types of messages there, <code>UserMoved</code>, <code>ViewingArea</code> and
        <code>UserPositions</code>.
    </p>

    <p>
        You may notice the annotations on the event classes.  These are Jackson annotations, used to specify how the
        classes get turned to and from JSON.  We won't go into too much detail here, you can read more about Play's
        JSON support <a href="http://www.playframework.com/documentation/latest/JavaJson" target="_blank">here</a>.
    </p>

    <p>
        You can see back in <a href="#code/app/controllers/Application.java" class="shortcut">Application.java</a>
        that we have told Play to use an actor to handle the WebSocket.  This means our JSON messages are sent to this
        actor, while when this actor sends JSON messages to the passed in upstream actor, these messages will be
        serialized and sent over the WebSocket to the client.
    </p>

    <p>
        Now browse to the <a href="#code/app/actors/ClientConnection.java" class="shortcut">ClientConnection</a>
        actor that we've defined to handle the WebSocket.  The onReceive method
        shows the handling of the different message types that this actor will receive.  We'll focus on just on of these
        message types.
    </p>

    <p>
        Each time a <code>UserMoved</code> event is received, it's translated to a <code>UserPosition</code> object,
        and sent to the <a href="#code/app/actors/RegionManagerClient.java" class="shortcut">RegionManagerClient</a>.
        This class is responsible for sending user position updates to the right node for the region that that position
        lives in.  You can see in that class that the first thing it does is look up the regionId, and then it creates
        a <code>UserPositionUpdate</code> message, and sends that message to a router.
    </p>

    <p>
        But how does that router get it to the right node?  The configuration for that router can be found in
        <a href="#code/conf/application.conf" class="shortcut">application.conf</a>.  Scrolling down to the
        configuration in the <code>akka</code> section, you'll see this:
    </p>
    
    <pre><code>/regionManagerClient/router {
  router = consistent-hashing
  nr-of-instances = 1000
  cluster {
    enabled = on
    routees-path = "/user/regionManager"
    allow-local-routees = on
    use-role = "backend-region"
  }
}</code></pre>

    <p>
        The routing to the node responsible for a region is done with a cluster aware 
        <a href="http://en.wikipedia.org/wiki/Consistent_hashing" target="_blank">consistent hashing</a>
        router. The region identifier is used as key for the consistent hashing. This means that updates
        for a region is routed to the backend node responsible for that region. When the number of nodes in
        the cluster changes the responsibility for a region may change. In this application the state of the
        regions don't have to be migrated when this happens. Updates for some regions are routed to a new 
        backend node and old data will expire. For a short period the region points (counts of users) might
        be slightly inaccurate, but that is acceptable for this application.       
    </p>
    
    <p>
        The hash code used to route messages is specified by the <code>ConsistentHashable</code> interface, you can see
        that the <a href="#code/app/backend/RegionManagerProtocol.java" class="shortcut">UpdateUserPosition</a> message
        implements this interface, and defines the hash key to be the region ID that the update is for.
    </p>
    
    <p>
        If you're interested in learning the full details of Akka routing and how to configure it, you can read about
        <a href="http://doc.akka.io/docs/akka/2.3.1/scala/routing.html" target="_blank">Routing</a> and
        <a href="http://doc.akka.io/docs/akka/2.3.1/scala/cluster-usage.html#Cluster_Aware_Routers" target="_blank">
        Cluster Aware Routers</a> in the Akka documentation.
    </p>

</div>
<div>

    <h2>The code - Backend</h2>

    <p>
        We've seen how the web frontend receives GPS user position events and then routes them to the right backend
        node in the Akka cluster.  Now let's find out what happens with the events when it reaches the backend node.
    </p>

    <p>
        In the configuration for the router that we saw before, we could see this config item defined:
    </p>

    <pre><code>routees-path = "/user/regionManager"</code></pre>

    <p>
        <code>/user</code> is the namespace for all user defined actors (as opposed to actors defined by the system
        itself), so this says that the messages get sent to a user defined actor called <code>regionManager</code>,
        which is implemented by the <a href="#code/app/backend/RegionManager.java" class="shortcut">RegionManager</a>
        class.
    </p>

    <p>
        The region manager is responsible for managing all the regions that belong on that node.  If it gets some data
        for a region, and an actor for that region doesn't exist yet, it creates it.  Once it has ensured that an actor
        exists for that region, then it sends the user position to that region.
    </p>

    <p>
        The actor class that represents a region is called
        <a href="#code/app/backend/Region.java" class="shortcut">Region</a>.  This class has a map called
        <code>activeUsers</code>, and when it receives the user position, it adds that users position to the map.
    </p>

</div>

<div>

    <h2>The code - Subscriptions between frontend and backend</h2>

    <p>
       A client displays a section of the map, which is decorated with live markers of other users in that area.
       How are those user positions published to the client?
    </p>
    
    <p>
       When the user zooms or changes map position the client sends a 
       <a href="#code/app/actors/ClientConnectionProtocol.java" class="shortcut">ViewingArea</a> event to the server, which
       ends up in <a href="#code/app/actors/PositionSubscriber.java" class="shortcut">PositionSubscriber</a> via
       the <a href="#code/app/actors/ClientConnection.java" class="shortcut">ClientConnection</a> actor.
       The PositionSubscriber works out which regions cover that viewing area, and then subscribes to updates from
       each of those regions.
    </p>
    
    <p>
       The published updates of user positions comes from the backend <a href="#code/app/backend/Region.java" class="shortcut">Region</a>
       actors. The thing that ties the publisher and subscriber together is the named topic, which in this case is
       the region id.
    </p>
    
    <p>
       In a similar way the PositionSubscriber may decide to subscribe to summary regions, and then the published 
       region points comes from the <a href="#code/app/backend/SummaryRegion.java" class="shortcut">SummaryRegion</a>
       actors.
    </p>

    <p>
       The <a href="http://doc.akka.io/docs/akka/2.3-M1/contrib/distributed-pub-sub.html" target="_blank">publish/subscribe</a>
       mechanism in Akka is a registry of subscribers that is replicated to members in the cluster. 
       There is no central hub or broker. When publishing a message to a named topic it sends the message to nodes with
       subscribers of that topic, and then delivers the message to all subscribing actors on that node. The message is sent
       over the wire only once per node that has at least one subscriber of the topic. The decoupling of publisher and
       subscriber makes it easy to add and remove nodes in the cluster as needed.
    </p>
    
    <p>
      Changes of subscribers are disseminated in a scalable way to other nodes with a gossip protocol. The registry is
      eventually consistent, i.e. changes are not immediately visible at other nodes, but typically they will be fully
      replicated to all other nodes after a few seconds.
    </p>
    
</div>

<div>

    <h2>The code - Summary</h2>

    <p>
        At this stage of the tutorial, we've seen:
    </p>

    <ul>
        <li>How the browser gets the users position from their GPS enabled device</li>
        <li>How the browser sends the users position to the web front end via WebSockets</li>
        <li>How the WebSocket is routed to the corresponding action</li>
        <li>How the WebSocket action sends the users position to an Akka router</li>
        <li>How the Akka router routes the users position to the correct node for the region in the Akka cluster</li>
        <li>How the node receives the users position and sends it to the right actor that manages that position</li>
        <li>How the backend nodes publishes updates to frontend subscribers</li>
    </ul>

    <p>
        And now for something completely different.
    </p>

</div>

<div>
    <h2>Add more nodes</h2>
    
    <p>
      So far you are <a href="#run" class="shortcut">running</a> the application in one single JVM, hosting both frontend
      and backend. Let's try to add more backend and frontend nodes to the cluster.
    </p>
    
    <p>
      Open a terminal and change directory to the root directory of the reactive-maps application. Start a backend node
      with the following command (on one line):
    </p>
    <pre><code>
    &lt;path to activator dir&gt;/activator 
      -Dakka.remote.netty.tcp.port=0 
      -Dakka.cluster.roles.1=backend-region 
      "run-main backend.Main"
    </code></pre>
    
    <p>
      This runs the <a href="#code/app/backend/Main.java" class="shortcut">backend.Main</a> class and
      overrides the configuration to bind Akka remoting to a random available port and use the "backend-region"
      cluster role for this node.
    </p> 
    
    <p>
      If you take a look at the log in <a href="#run" class="shortcut">Run</a> you can see that the new node
      joined the cluster. The new node knows how to join the cluster because the first node running on port 2552
      is configured as initial contact point in the 'seed-nodes' property in the 
      <a href="#code/conf/application.conf" class="shortcut">application.conf</a>. 
      You can read more about Akka Clustering in the
      <a href="http://doc.akka.io/docs/akka/2.2.3/scala/cluster-usage.html" target="_blank">documentation</a>.  
    </p>
    
    <p>
      You can repeat the command in new terminal windows to add more backend nodes.
    </p>
    
    <p>
      You can also add more simulated users with the following command (on one line):
    </p>
    <pre><code>
    &lt;path to activator dir&gt;/activator 
      -Dakka.remote.netty.tcp.port=0 
      -Dakka.cluster.roles.1=frontend 
      -DreactiveMaps.bots.totalNumberOfBots=500 
      "run-main backend.Main"		
	</code></pre>
	
	<p>
	  The following command (on one line) will start another frontend node listening on HTTP port 9001: 
	</p>
	<pre><code>
    &lt;path to activator dir&gt;/activator 
      -Dhttp.port=9001
      -Dakka.remote.netty.tcp.port=0
      -Dakka.cluster.roles.1=frontend 
      run
    </code></pre>
    <p>
      Try the added frontend in a new browser window: <a href="http://localhost:9001" target="_blank">http://localhost:9001</a>
    </p>
    
</div>

<div>
    <h2>Adding a new feature</h2>

    <p>
        Now that we've had a detailed look at some of the system, let's try and add a new feature. Until now, our view
        of the data has been region based - all data is associated with and stored in an actor for a region.  This
        allows us to shard regions over multiple nodes, allowing efficient access to the data by node.
    </p>

    <p>
        We're going to add functionality that is user based.  We'll use exactly the same methods for scaling as for the
        region based data, so we can see how to build such a system from scratch.
    </p>

    <p>
        We'll start off with a simple implementation that only works when there is one node, implementing first the
        backend, then the client side.  Then we'll demonstrate how this implementation can be scaled out to shard the
        data across many nodes.  Finally we'll show some techniques for ensuring data consistency when nodes are
        introduced into or removed from the cluster.
    </p>

    <p>
        The new feature that we'll add is tracking the distance that a user has travelled.  We'll make the client
        fetch this data when a user clicks on a marker.
    </p>

</div>

<div>
    <h2>Handling the maths</h2>

    <p>
        The first thing we need to do is add a function for calculating the distance between two points.  There are
        many such formulas that can be used to do this, but a simple general purpose one which will suit our purposes
        is called the <a href="http://www.movable-type.co.uk/scripts/latlong.html" target="_blank">haversine</a>
        formula.
    </p>

    <p>
        Let's create a new method called <code>distanceBetweenTwoPoints</code> in
        <code>GeoFunctions</code>:
    </p>

<div class="codeSnippet">
  <div class="location">
    <a href="#code/app/backend/GeoFunctions.java:239">GeoFunctions.java:239</a>
  </div>
  <pre><code>    public double distanceBetweenPoints(LatLng pointA, LatLng pointB) {
        // Setup the inputs to the formula
        double R = 6371009d; // average radius of the earth in metres
        double dLat = Math.toRadians(pointB.getLat() - pointA.getLat());
        double dLng = Math.toRadians(pointB.getLng() - pointA.getLng());
        double latA = Math.toRadians(pointA.getLat());
        double latB = Math.toRadians(pointB.getLat());

        // The actual haversine formula. a and c are well known value names in the formula.
        double a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.sin(dLng / 2) * Math.sin(dLng / 2) *
            Math.cos(latA) * Math.cos(latB);
        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        double distance = R * c;

        return distance;
    }</code></pre>
</div>


</div>

<div>
    <h2>User meta data register</h2>

    <p>
        The first thing we need to implement is a user meta data register.  As a first implementation, we'll write one
        actor that will store all user meta data, we'll call it <code>UserMetaData</code>.  First we'll define the
        protocol with which we'll speak to this actor, create a new file called
        <code>app/backend/UserMetaDataProtocol.java</code> now, and start off by adding the following:
    </p>

<div class="codeSnippet">
  <div class="location">
    <a href="#code/app/backend/UserMetaDataProtocol.java:1">UserMetaDataProtocol.java:1</a>
  </div>
  <pre><code>package backend;

import com.fasterxml.jackson.annotation.*;
import models.backend.LatLng;

public abstract class UserMetaDataProtocol {
    public static class GetUser {
        private final String id;

        public GetUser(String id) {
            this.id = id;
        }

        public String getId() {
            return id;
        }
    }

    public static class User {
        private final String id;
        private final double distance;

        @JsonCreator
        public User(@JsonProperty("id") String id, @JsonProperty("distance") double distance) {
            this.id = id;
            this.distance = distance;
        }

        public String getId() {
            return id;
        }

        public double getDistance() {
            return distance;
        }
    }

    public static class UpdateUserPosition {
        private final String id;
        private final LatLng position;

        public UpdateUserPosition(String id, LatLng position) {
            this.id = id;
            this.position = position;
        }

        public String getId() {
            return id;
        }

        public LatLng getPosition() {
            return position;
        }
    }
}</code></pre>
</div>

    <p>
        We've got three different message types in the protocol for this actor, it will receive
        <code>UpdateUserPosition</code> messages to update the user position, and will receive
        <code>GetUser</code> messages, and send back <code>User</code> messages to the sender.
    </p>

    <p>
        Now implement the actor itself in a file called <code>app/backend/UserMetaData.java</code>:
    </p>

<div class="codeSnippet">
  <div class="location">
    <a href="#code/app/backend/UserMetaData.java:1">UserMetaData.java:1</a>
  </div>
  <pre><code>package backend;

import models.backend.*;
import akka.actor.*;
import backend.UserMetaDataProtocol.*;
import play.libs.F.Tuple;
import java.util.*;

public class UserMetaData extends UntypedActor {

    public static Props props() {
        return Props.create(UserMetaData.class, UserMetaData::new);
    }

    private final SettingsImpl settings = Settings.SettingsProvider.get(getContext().system());
    private final Map&lt;String, Tuple&lt;LatLng, Double&gt;&gt; users = new HashMap&lt;&gt;();

    public void onReceive(Object msg) {
    }
}</code></pre>
</div>

    <p>
        Our actor depends on the settings (which provides the <code>GeoFunctions</code> class we already edited), and
        has a map that maps the userId to a tuple of the last position the user was seen at, and the distance they've
        travelled. We'll now implement handling the <code>GetUser</code> message in the <code>receive</code> method:
    </p>

<div class="codeSnippet">
  <div class="location">
    <a href="#code/app/backend/UserMetaData.java:19">UserMetaData.java:19</a>
  </div>
  <pre><code>        if (msg instanceof GetUser) {
            GetUser getUser = (GetUser) msg;
            Tuple&lt;LatLng, Double&gt; user = users.get(getUser.getId());
            if (user != null) {
                sender().tell(new User(getUser.getId(), user._2), self());
            } else {
                sender().tell(new User(getUser.getId(), 0), self());
            }
        }</code></pre>
</div>

    <p>
        You can see that if the user wasn't found, we just return 0.  Now implement handling the
        <code>UpdateUserPosition</code> message:
    </p>

<div class="codeSnippet">
  <div class="location">
    <a href="#code/app/backend/UserMetaData.java:28">UserMetaData.java:28</a>
  </div>
  <pre><code>        else if (msg instanceof UpdateUserPosition) {
            UpdateUserPosition update = (UpdateUserPosition) msg;
            Tuple&lt;LatLng, Double&gt; user = users.get(update.getId());
            if (user != null) {
                users.put(update.getId(), new Tuple&lt;&gt;(update.getPosition(),
                    user._2 + settings.GeoFunctions.distanceBetweenPoints(user._1, update.getPosition())
                ));
            } else {
                users.put(update.getId(), new Tuple&lt;&gt;(update.getPosition(), 0d));
            }
        }</code></pre>
</div>


    <p>
        You can see here we're using the <code>distanceBetweenPoints</code> method we implemented earlier, updating the
        distance if we have a last position to compare it to, and updating the map with the new user data.
    </p>

</div>

<div>
    <h2>Send user position updates</h2>

    <p>
        Now we need to implement the code that sends the user position updates to this actor.  This is a little tedious
        because there a two things that will do this, the web client, and the bots.  We'll start with the web client.
    </p>

    <p>
        The web client is initialised by a Play plugin called <code>Actors</code>.  In this class, add a
        new variable for the user meta data actor and start it in the <code>onStart</code> method:
    </p>

<div class="codeSnippet">
  <div class="location">
    <a href="#code/app/actors/Actors.java:34">Actors.java:34</a>
  </div>
  <pre><code>    private ActorRef userMetaData;</code></pre>
</div>
<div class="codeSnippet">
  <div class="location">
    <a href="#code/app/actors/Actors.java:44">Actors.java:44</a>
  </div>
  <pre><code>        userMetaData = system.actorOf(UserMetaData.props(), "userMetaData");</code></pre>
</div>

    <p>
        Now provide access to this in the <code>Actors</code> object in the same way that
        <code>regionManagerClient</code> is made accessible:
    </p>

<div class="codeSnippet">
  <div class="location">
    <a href="#code/app/actors/Actors.java:31">Actors.java:31</a>
  </div>
  <pre><code>    public static ActorRef userMetaData() {
        return actors().userMetaData;
    }
</code></pre>
</div>

    <p>
        The class that will ultimately use this actor is the
        <code>ClientConnection.java</code> actor.  Open it,
        and modify the constructor of <code>ClientConnection</code> to accept it as a parameter:
    </p>

<div class="codeSnippet">
  <div class="location">
    <a href="#code/app/actors/ClientConnection.java:33">ClientConnection.java:33</a>
  </div>
  <pre><code>    private final ActorRef userMetaData;

    private ClientConnection(String email, ActorRef upstream, ActorRef regionManagerClient, ActorRef userMetaData) {
        this.email = email;
        this.upstream = upstream;
        this.regionManagerClient = regionManagerClient;
        this.userMetaData = userMetaData;

        this.subscriber = getContext().actorOf(PositionSubscriber.props(self()), "positionSubscriber");
    }</code></pre>
</div>

    <p>
        Now when the client sends a <code>UserMoved</code> message through the web socket, in addition to sending a
        message to the <code>regionManagerClient</code>, we also want to update the user meta data:
    </p>

<div class="codeSnippet">
  <div class="location">
    <a href="#code/app/actors/ClientConnection.java:8">ClientConnection.java:8</a>
  </div>
  <pre><code>import backend.UserMetaDataProtocol.UpdateUserPosition;</code></pre>
</div>
<div class="codeSnippet">
  <div class="location">
    <a href="#code/app/actors/ClientConnection.java:51">ClientConnection.java:51</a>
  </div>
  <pre><code>                LatLng position = LatLng.fromLngLatAlt(userMoved.getPosition().getCoordinates());
                regionManagerClient.tell(new PointOfInterest.UserPosition(email, System.currentTimeMillis(),
                        position), self());
                userMetaData.tell(new UpdateUserPosition(email, position), self());</code></pre>
</div>

    <p>
        Since we added a constructor parameter to the <code>ClientConnection</code> actor, we also need to update its
        <code>props</code> method to also accept and pass the user meta data actor:
    </p>

<div class="codeSnippet">
  <div class="location">
    <a href="#code/app/actors/ClientConnection.java:26">ClientConnection.java:26</a>
  </div>
  <pre><code>    public static Props props(String email, ActorRef upstream, ActorRef regionManagerClient, ActorRef userMetaData) {
        return Props.create(ClientConnection.class, () -&gt; new ClientConnection(email, upstream, regionManagerClient, userMetaData));
    }</code></pre>
</div>

    <p>
        And finally, we need to pass the actor in to the place that uses this, the
        <code>Application</code> controller, using the
        <code>userMetaData</code> method on <code>Actors</code> that we just wrote:
    </p>

<div class="codeSnippet">
  <div class="location">
    <a href="#code/app/controllers/Application.java:21">Application.java:21</a>
  </div>
  <pre><code>      return WebSocket.withActor(upstream -&gt; ClientConnection.props(email, upstream, Actors.regionManagerClient(),
              Actors.userMetaData()));</code></pre>
</div>


    <p>
        The web front end is set to go, but the bots also need to be updated.  As with <code>ClientConnection</code>,
        add a constructor parameter for the user meta data to <code>GeoJsonBot.java</code>:
    </p>

<div class="codeSnippet">
  <div class="location">
    <a href="#code/app/actors/GeoJsonBot.java:30">GeoJsonBot.java:30</a>
  </div>
  <pre><code>    private final ActorRef userMetaData;

    public GeoJsonBot(LineString trail, double offsetLat, double offsetLng, String userId, ActorRef regionManagerClient,
            ActorRef userMetaData) {
        this.userMetaData = userMetaData;</code></pre>
</div>

    <p>
        And immediately after the bot sends a position update to the <code>regionManagerClient</code>, make it also
        send one to <code>userMetaData</code>:
    </p>

<div class="codeSnippet">
  <div class="location">
    <a href="#code/app/actors/GeoJsonBot.java:4">GeoJsonBot.java:4</a>
  </div>
  <pre><code>import backend.UserMetaDataProtocol.UpdateUserPosition;</code></pre>
</div>
<div class="codeSnippet">
  <div class="location">
    <a href="#code/app/actors/GeoJsonBot.java:65">GeoJsonBot.java:65</a>
  </div>
  <pre><code>            LatLng position = new LatLng(c.getLatitude() + offsetLat, c.getLongitude() + offsetLng);
            UserPosition userPos = new UserPosition(userId, System.currentTimeMillis(), position);
            regionManagerClient.tell(userPos, self());
            userMetaData.tell(new UpdateUserPosition(userId, position), self());</code></pre>
</div>

    <p>
        Update the props method:
    </p>

<div class="codeSnippet">
  <div class="location">
    <a href="#code/app/actors/GeoJsonBot.java:19">GeoJsonBot.java:19</a>
  </div>
  <pre><code>    public static Props props(LineString trail, double offsetLat, double offsetLng, String userId,
                              ActorRef regionManagerClient, ActorRef userMetaData) {
        return Props.create(GeoJsonBot.class, () -&gt; new GeoJsonBot(trail, offsetLat, offsetLng, userId,
                regionManagerClient, userMetaData));
    }</code></pre>
</div>

    <p>
        Now this is called by <code>BotManager</code>, modify the props method, constructor parameter and the
        the call that creates the bot:
    </p>

<div class="codeSnippet">
  <div class="location">
    <a href="#code/app/backend/BotManager.java:25">BotManager.java:25</a>
  </div>
  <pre><code>    public static Props props(ActorRef regionManagerClient, ActorRef userMetaData, List&lt;URL&gt; data) {
        return Props.create(BotManager.class, () -&gt; new BotManager(regionManagerClient, userMetaData, data));
    }

    private final ActorRef regionManagerClient;
    private final ActorRef userMetaData;
    private final List&lt;URL&gt; data;

    public BotManager(ActorRef regionManagerClient, ActorRef userMetaData, List&lt;URL&gt; data) {
        this.regionManagerClient = regionManagerClient;
        this.userMetaData = userMetaData;
        this.data = data;
    }</code></pre>
</div>
<div class="codeSnippet">
  <div class="location">
    <a href="#code/app/backend/BotManager.java:76">BotManager.java:76</a>
  </div>
  <pre><code>                        if (originalTrail) {
                            getContext().actorOf(GeoJsonBot.props(route, 0, 0, userId, regionManagerClient, userMetaData));
                        } else {
                            getContext().actorOf(GeoJsonBot.props(route,
                                    ThreadLocalRandom.current().nextDouble() * 15.0,
                                    ThreadLocalRandom.current().nextDouble() * -30.0, userId, regionManagerClient, userMetaData));
                        }</code></pre>
</div>

    <p>
        <code>BotManager</code> is initialised in two places, once in the web front end by Play in the
        <code>Actors</code> class, so update that to pass the <code>userMetaData</code>:
    </p>

<div class="codeSnippet">
  <div class="location">
    <a href="#code/app/actors/Actors.java:63">Actors.java:63</a>
  </div>
  <pre><code>            system.actorOf(BotManager.props(regionManagerClient, userMetaData, urls));</code></pre>
</div>

    <p>
        And finally, we need to update the <code>Main</code> class, this
        is used when running a non Play node in the cluster.  Initialise the <code>UserMetaData</code> actor after
        creating <code>RegionManagerClient</code>:
    </p>

<div class="codeSnippet">
  <div class="location">
    <a href="#code/app/backend/Main.java:36">Main.java:36</a>
  </div>
  <pre><code>            ActorRef userMetaData = system.actorOf(UserMetaData.props(), "userMetaData");</code></pre>
</div>

    <p>
        Now pass the actor to the <code>BotsManager</code> props methed:
    </p>

<div class="codeSnippet">
  <div class="location">
    <a href="#code/app/backend/Main.java:46">Main.java:46</a>
  </div>
  <pre><code>            system.actorOf(BotManager.props(regionManagerClient, userMetaData, urls));</code></pre>
</div>


</div>

<div>
    <h2>Exposing user data to the web</h2>

    <p>
        The users distance is going to be requested by the user on an as needed basis.  Since the action is triggered
        by the user and the user expects a response, it makes sense in this case to use a simple HTTP request to get
        the data.  So we're going to write a Play action to get the user meta data.
    </p>

    <p>
        Create a new Java class called <code>controllers.UserController</code>:
    </p>

<div class="codeSnippet">
  <div class="location">
    <a href="#code/app/controllers/UserController.java:1">UserController.java:1</a>
  </div>
  <pre><code>package controllers;

import actors.Actors;
import static akka.pattern.Patterns.ask;

import backend.UserMetaDataProtocol.*;
import play.libs.F.*;
import play.libs.Json;
import play.mvc.*;


public class UserController extends Controller {

}</code></pre>
</div>

    <p>
        Now implement an action that does an ask on the user meta data actor for the user, and serialises it out as
        JSON:
    </p>

<div class="codeSnippet">
  <div class="location">
    <a href="#code/app/controllers/UserController.java:13">UserController.java:13</a>
  </div>
  <pre><code>    public static Promise&lt;Result&gt; get(String id) {
        Promise&lt;Object&gt; answer =
                Promise.wrap(ask(Actors.userMetaData(), new GetUser(id), 2000));

        return answer.map(a -&gt; {
            User user = (User) a;
            return ok(Json.toJson(user));
        });
    }</code></pre>
</div>

    <p>
        The last thing we need to do on the server side is declare how requests will be routed to this action.  We do
        this in the <code>routes</code> file:
    </p>

<div class="codeSnippet">
  <div class="location">
    <a href="#code/conf/routes:10">routes:10</a>
  </div>
  <pre><code>GET        /user/:email         controllers.UserController.get(email)</code></pre>
</div>


    <p>
        You can see that we are defining a dynamic route with an <code>email</code> parameter, signalled by the colon
        before the parameter name.  Then we invoke the action we just created, passing that <code>email</code>
        parameter as the id of the user.
    </p>
</div>

<div>
    <h2>Consuming user data on the client side</h2>

    <p>
        Now that we've got the server side ready, we can write the client side code to consume the new action we just
        created.  Let's start with creating a new module,
        <code>app/assets/javascripts/services/userInfo.coffee</code>, that will
        make the AJAX call.  Although this module will be very simple, it's best practice to split out the making of
        AJAX calls from the business logic of your code, so you can easily mock and test.
    </p>

<div class="codeSnippet">
  <div class="location">
    <a href="#code/app/assets/javascripts/services/userInfo.coffee:1">userInfo.coffee:1</a>
  </div>
  <pre><code>define ["jquery"], -&gt;
  {
    get: (email) -&gt;
      $.getJSON("/user/" + email)
  }</code></pre>
</div>

    <p>
        Our <code>userInfo</code> module depends on <code>jquery</code>, and simply provides one method,
        <code>get</code>, which calls the action.  jQueries <code>getJSON</code> method returns a promise of the json,
        so we can consume that by attaching <code>then</code> or <code>done</code> callbacks to the returned promise.
    </p>

    <p>
        Now in <code>marker.coffee</code>, we want to
        use this service to look up the user info.  So we will add the <code>userInfo</code> module as a dependency.  If
        you're familiar with requireJS, you might notice that we're not using a relative path name here, this is because
        we are using path aliases that we configure elsewhere, this also makes mocking dependencies simpler, as it
        decouples modules from their implementation.
    </p>

<div class="codeSnippet">
  <div class="location">
    <a href="#code/app/assets/javascripts/map/marker.coffee:4">marker.coffee:4</a>
  </div>
  <pre><code>define ["leaflet", "markerRenderer", "userInfo"], (Leaflet, renderer, userInfo) -&gt;</code></pre>
</div>

    <p>
        In the constructor of the <code>Marker</code> class, after attaching the popup to the marker, we want to bind
        to the click event of the marker so that we can update the popup with the users distance each time the user
        clicks on it:
    </p>

<div class="codeSnippet">
  <div class="location">
    <a href="#code/app/assets/javascripts/map/marker.coffee:24">marker.coffee:24</a>
  </div>
  <pre><code>        @marker.bindPopup(renderer.renderPopup(userId))

        @marker.on "click", =&gt;
          userInfo.get(userId).done (user) =&gt;
            @marker.getPopup()
              .setContent(renderer.renderPopup(userId, user.distance)).update()</code></pre>
</div>

    <p>
        And now we want to handle that additional distance parameter that we've passed to <code>renderPopup</code>,
        in <code>markerRenderer.coffee</code>:
    </p>

<div class="codeSnippet">
  <div class="location">
    <a href="#code/app/assets/javascripts/map/markerRenderer.coffee:15">markerRenderer.coffee:15</a>
  </div>
  <pre><code>  renderPopup: (userId, distance) -&gt;
    popup = "&lt;p&gt;&lt;img src='http://www.gravatar.com/avatar/" +
      md5(userId.toLowerCase()) + "'/&gt;&lt;/p&gt;&lt;p&gt;" + escapeHtml(userId) + "&lt;/p&gt;"
    if (distance)
      popup + "&lt;p&gt;Travelled: " + Math.floor(distance) + "m&lt;/p&gt;"
    else
      popup</code></pre>
</div>

    <p>
        Finally, since we've defined the new <code>userInfo</code> module, we need to declare what the path for that
        module is.  This can be done in <code>main.coffee</code>:
    </p>

<div class="codeSnippet">
  <div class="location">
    <a href="#code/app/assets/javascripts/main.coffee:14">main.coffee:14</a>
  </div>
  <pre><code>    userInfo: "./services/userInfo"</code></pre>
</div>


    <p>
        And now we should be good to go, refresh your browser, and try clicking on a marker to see if the distance is
        rendered.  If you're looking at the bots walking around North Carolina, you might see that they are moving at
        hundreds of metres per second - these bots are designed to provide interesting data, not necessarily realistic
        data.
    </p>

</div>


<div>
    <h2>Client side testing</h2>

    <p>
        After making the previous changes to the client side logic, we've left some of the client side tests in a failing
        state.  Let's fix them.  Start by running them to see that they are failing, by going to the
        <a href="#test" class="shortcut">test</a> tab.  Run the tests, you should see some of them are failing.
    </p>

    <p>
        We're using mocha to write tests, in combination with Squire.js to mock out Require.js dependencies.  We've
        also been very careful to design our client side code in such a way that the DOM manipulation code, and any code
        doing AJAX or WebSockets or using any other browser based APIs are separated from the business logic.  This
        allows us to comprehensively test the important code.
    </p>

    <p>
        Open <a href="#code/test/assets/javascripts/map/MarkerSpec.coffee">MarkerSpec.coffee</a>.  This is where our
        failing tests are.  Since we've added a new user info service that
        <a href="#code/app/assets/javascripts/map/Marker.coffee">Marker.coffee</a> depends on, we need to create a
        mocked version for this:
    </p>

<div class="codeSnippet">
  <div class="location">
    <a href="#code/test/assets/javascripts/map/MarkerSpec.coffee:21">MarkerSpec.coffee:21</a>
  </div>
  <pre><code>class MockUserInfo
  users: {}
  get: (userId) -&gt;
    new MockPromise({
      distance: @users[userId]
    })</code></pre>
</div>

    <p>
        Now to test that the marker correctly passes the looked up user distance to marker renderer, we'll modify the
        <code>MockMarkerRenderer.renderPopup</code> method to "render" it:
    </p>

<div class="codeSnippet">
  <div class="location">
    <a href="#code/test/assets/javascripts/map/MarkerSpec.coffee:47">MarkerSpec.coffee:47</a>
  </div>
  <pre><code>  renderPopup: (userId, distance) -&gt;
    if distance
      userId + ":" + distance
    else
      "Popup " + userId</code></pre>
</div>

    <p>
        Now lets modify the test setup code to instantiate and mock the mock user info service that we created:
    </p>

<div class="codeSnippet">
  <div class="location">
    <a href="#code/test/assets/javascripts/map/MarkerSpec.coffee:66">MarkerSpec.coffee:66</a>
  </div>
  <pre><code>    # Create mocks
    leaflet = new MockLeaflet()
    renderer = new MockMarkerRenderer()
    userInfo = new MockUserInfo()

    # Mockout require js environment
    new Squire()
    .mock("markerRenderer", renderer)
    .mock("leaflet", leaflet)
    .mock("userInfo", userInfo)
    .require ["javascripts/map/marker"], (Marker) -&gt;
        test({
          leaflet: leaflet,
          userInfo: userInfo,
          renderer: renderer,
        }, Marker)
        done()</code></pre>
</div>

    <p>
        Now try running the tests again. They should pass. Finally, let's add a new test that tests that the popup
        is updated with the distance when the marker is clicked:
    </p>

<div class="codeSnippet">
  <div class="location">
    <a href="#code/test/assets/javascripts/map/MarkerSpec.coffee:137">MarkerSpec.coffee:137</a>
  </div>
  <pre><code>  it "should update the popup with the current distance when clicked", testMarker (deps, Marker) -&gt;
    marker = new Marker(new MockMap(), single, new LatLng(10, 20))
    deps.userInfo.users["userid"] = 50
    marker.marker.onClick()
    assert.equal("userid:50", marker.marker.popup.content)</code></pre>
</div>


    <p>
        Run the tests to ensure the new test also passes.
    </p>

</div>

<div>
    <h2>Learn more about reactive design</h2>
    
    <p>
      Essential characteristic of a reactive application:
    </p>
    <ul>
      <li>react to events - the event-driven nature enables the following qualities</li>
      <li>react to load - focus on scalability by avoiding contention on shared resources</li>
      <li>react to failure - build resilient systems with the ability to recover at all levels</li>
      <li>react to users - honor response time guarantees regardless of load</li>
    </ul>
    
    <p>
      Read more about how to build reactive applications in the 
      <a href="http://www.reactivemanifesto.org/" target="_blank"><b>Reactive Manifesto</b></a>.
    </p>
    
</div>

</body>
</html>
